

Tcl 脚本编程规范 
1.1 版 









华 为 技 术 有 限 公 司
版权所有 侵权必究 

前 言
本规范对Tcl 脚本编程风格作了明确规定，为Tcl 测试脚本的规范化、模块化和货架化输出确立了一个基本框架。本规范适用于Tcl 脚本编程指导、测试脚本和模块的交流与共享，以及作为测试脚本库建设的基本规范。 
本规范采用下面术语描述： 
【规则】：脚本编程时必须遵守的基本原则。 
【建议】：脚本编程时推荐采用的编程风格。 
本规范涉及的编程规则和建议覆盖了Tcl 脚本编程的排版、注释、可读性、标识符命名、变量与过程、名称空间和包、文件操作、出错和调试、脚本移植和优化等主题。规范中所有示例均采用标准Tcl 语言编写，并在Tcl for Windows 8.3.2 解释器中调试通过。 
需要说明的是，Tcl 扩展函数编程和Tk脚本编程暂未纳入本规范的约束范畴。本规范遵循公司已有规范，未明确规定部分按公司要求执行。 
本规范由测试中心单板软件测试研究部提出。 
本规范主要起草人：罗建川 
本规范批准人： 
本规范所替代的历次修订情况为： 
本规范的历次修订人为： 
杨文龙 将部分产品规范合入现有规范中，以求一致 09-17-2002 

Tcl 脚本编程规范 
1排版
【规则1-1】脚本采用缩进风格编写，缩进空格数为4。 
说明：由于不同编辑器对TAB键的处理不同，为保证脚本格式一致，建议在脚本完成后通过UltraEdit等软件将TAB键直接转化为相应数量的空格；过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格。或者就不使用TAB键而直接使用空格键操作，以免用不同的编辑器阅读程序时，因TAB键所设置的空格数目不同而造成程序布局不整齐。 
【规则1-2】相对独立的程序块之间用空行分开，以增加可读性。 
示例： 
set FileHandle [open $FileName r] 
set CommandFlag 0; #一组命令的起止标志，0代表结束，1代表进行中 
set MapFlag 0; 
set MapCount 1; #命令map的大小 
while {[expr ![eof $FileHandle]]} { 
# body of while 
} 
【规则1-3】一行只写一条命令，不允许把多个短命令写在同一行中。 
如： 
set var 1; expr $var -1; 
这样的格式是错误的。应该如下： 
set var 1 
expr $var -1 
【规则1-4】较长的语句（多于80个字符）要分成多行书写，每行控制在80个字符以内，分多行书写的命令用字符“\”续行；划分出的新行要进行适当的缩进，使排版整齐，语句可读。 
如：长表达式要在低优先级操作符处划分新行，操作符放在新行之首。 
【规则1-5】控制结构命令（如if、for和switch等）包括命令字、控制参数和命令体。其中，命令字、控制参数和命令体的开括号占一行，命令体另起新行缩进编排，命令体的闭括号独占一行且与命令字对齐。控制参数采用花括号组合。 
示例1：for 语句和if 语句示例，控制参数采用花括号组合。
for {set i 0} {$i < 100} {incr i} { 
if {($i % 2) == 0} { 
incr EvenSum $i 
} else { 
incr OddSum $i 
} 
incr TotalSum $i 
} 
示例2：foreach 语句和switch 语句示例，控制参数不需要组合。
foreach Sample $SampleDataList { 
switch [expr $Sample % 3] { 
0 {lappend List1 $i} 
1 {lappend List2 $i} 
2 {lappend List3 $i} 
default {puts error} 
} 
} 
【规则1-6】实体命令（如proc和namespace）包括命令字、命令参数和命令体。 其中，命令字、命令参数与命令体的开括号占一行，命令体另起新行缩进编排，命令体的闭括号独占一行且与命令字对齐。 
示例：namespace 命令和proc 命令示例
namespace eval Random { 
variable Seed [clock seconds] 
namespace export Random Range 
proc Init { value } { 
variable Seed 
set Seed $value 
} 
proc Random {} { 
variable Seed 
set Seed [expr ($Seed*9301 + 49297) % 233280] 
return [expr $Seed/double(233280)] 
} 
proc Range { range } { 
expr int([Random]*$range) 
} 
} 
【规则1-7】对于其它由花括号组合多条命令构成的复合语句，命令体的开括号跟随命令及其参数占一行，命令体另起新行缩进编排，命令体的闭括号独占一行且与命令第一行首部对齐。 
示例： 
after 3000 { 
if {[recvmsg $MsgBuf] == 0} { 
puts "Time out,there are no acknowledge." 
} 
} 
【建议1-1】每行代码后面不允许有多余的空格。 
2注释
【规则2-1】一般情况下，源程序有效注释量不得低于20％。 
【规则2-2】多文件模块一般由多个子模块组成，每个子模块可能是一个单文件模块或多文件模块。对于这样的公用模块，必须提供相应的帮助文档详细说明模块的组成结构、文件列表、模块功能、使用方法、应用环境以及注意事项等。 
【规则2-3】文件的注释规则，参见『文件』一节的描述。 
【规则2-4】名称空间的头部必须进行注释，注释模板如下： 
示例：名称空间头注释模板
################################################################### 
# Namespace: 名称空间 
# Description: 功能描述 
# Variables: 名称空间变量列表 
# Procs: 名称空间过程列表 
# SubNamespace: 子名称空间列表 
#################################################################### 
【规则2-5】过程的注释规则，参见『过程』一节的描述。 
【规则2-6】注释必须放在其描述的代码的上方或右方相邻位置，不可放在下面，如置于上方则需与前面的代码用空行隔开，且与所注释代码同样缩进。 
【规则2-7】对于命名不是充分自注释的变量，定义时必须加以注释，说明其含义。 
【规则2-8】对于主要和易混淆的变量给予明确的注释。 
【建议2-1】注释应当阐述编程思路或代码用途，避免没有意义的注释。 
示例：没有意义的注释
set AsTime 0 ; # 定义变量AsTime 
【建议2-2】通过对变量、过程、名字空间和包等标识符的正确命名，以及合理地组织代码结构，使代码成为自注释的。 
说明：清晰准确的标识符命名可增加代码的可读性，减少不必要的注释； 
【建议2-3】条件分支语句的各分支应当加注释。 
3可读性
【规则3-1】避免使用不易理解的数字表示循环边界或特定状态，而应当使用变量或常量来达到上述目的。 
示例：使用常量MAX_MSG_LEN表示消息的最大长度
set MAX_MSG_LEN 1024 
while {$MsgLen > MAX_MSG_LEN} { 
puts "message length error" 
return error 
} 
【规则3-2】命令的嵌套层次不得大于3。 
示例：两层命令嵌套
set MsgLen [getbyte [expr $MsgBuf + 2]] 
【建议3-1】源程序中关系较为紧密的代码应尽可能相邻。 
【建议3-2】尽量避免构造特别复杂冗长的命令或表达式。 
【建议3-3】注意表达式中运算符的优先级，并用括号明确其操作顺序，避免使用默认优先级。 
【建议3-4】表达式中二元运算符前后各加一个空格。 
4标识符命名
【规则4-1】标识符命名要清楚明了，有明确含义，尽量使用完整的单词或基本可以理解的缩写，避免使人产生误解。 
【规则4-2】对于不能充分自注释的标识符命名，必须有注释说明。 
【规则4-3】避免使用单字符变量，但i、j、k作局部循环变量使用是允许的。 
【规则4-4】在同一个工程或模块中，命名风格必须保持一致。 
说明：公司常用的命名风格包括匈牙利命名法和驼峰命名法。 
【建议4-1】为减少模块间耦合，防止标识符命名冲突，使用名称空间或模块前缀限定模块中标识符的作用域。 
【建议4-2】尽量避免过程作用域中定义的局部变量与全局作用域（包括名称空间）中定义的公用变量重名，以免引起误解乃至误用。 
【建议4-3】全局变量名加前缀“g”，作为常量使用的变量名采用全大写风格，以表征上述变量的特征。 
示例：
set gHostName [info hostname] 
set MAX_MSG_LEN 1024 
【建议4-4】过程命名应能体现过程完成的功能，建议采用动宾词组为过程命名。 
5变量
【规则5-1】尽量使用数组或列表来组织一组相互关联的变量。 
示例： 
set id 12345 
set Employee($id,name) $Name 
set Employee($id,department) $Department 
set Employee($id,phone) $Phone 
set Employee($id,manager) $Manager 
【规则5-2】使用incr命令实现变量的递增和递减，不要使用expr命令。 
【规则5-3】用完整的英文或者约定成俗的简写命名变量。 
示例： 
广播MAC地址可定义为： BoardcastMac 
【规则5-4】每行只能定义一个变量。 
即如下格式为非法： 
set PathNo1 2； set PathNo2 3 
【规则5-5】不同类的变量定义之间保留一个空行以示区分。 
示例： 
#### 接口板的槽号########## 
set SlotNo1 2 
set SlotNo2 3 
#### 接口板的端口号######## 
set PortNo $SlotPortFirstNo 
【规则5-6】变量名用大小写混排的方式，不用下划线，并反应出实际意义，并在前面加上前缀，以增强程序的可读性，对于极少数约定俗成的变量可以采用简单命名。 
示例1：循环变量定义成 i 
示例2： 
vlan接口的最大个数建议定义为：MaxVlanInterface 
而不是： Max_vlan_interface 
【规则5-7】同类型变量排序应该以1、2等阿拉伯数字标明，而非英文字母或其它符号。注意：变量的末尾尽量不采用字母“l”作为结尾，以免与数字“1”发生误解 
示例： 
Vlan1, Vlan2 
而不是：VlanA，VlanB 
【规则5-8】编写代码时注意对齐，例如设置变量时，赋值时字符串上、下行对齐 
示例： 
set DefaultVlanId 1 
set MaxVlanInterface 64 
####广播风暴抑制比 
set MinBroadcastSuppression 0 
set MaxBroadcastSuppression 100 
####广播风暴抑制比步长 
set StepBroadcastSuppression 50 
【规则5-9】自定义全局变量的命名，为防止与公共脚本库中的冲突，建议开头一律采用g开头 
示例： 
set gMyGlobalVar 256 
【规则5-10】定义数组变量时，加前缀a来表示这是一个数组变量。当数组是个全局数组变量时，加前缀g表示。即前缀可以混合使用。 
示例： 
set gaTest(dir,home) $::AutoSailPath 
set gaTest(dir,data) [file join $gaTest(dir,home) data] 
set gaTest(dir,test) [file join $gaTest(dir,home) testtask] 
set gaTest(dir,device) [file join $gaTest(dir,home) device] 
set gaTest(dir,script) [file join $gaTest(dir,home) script] 
set gaTest(dir,utility) [file join $gaTest(dir,home) utility] 
【规则5-11】去掉没必要的公共变量 
说明：公共变量是增大模块间耦合的原因之一，故应减少没必要的公共变量以降低模块间的耦合度。 
6过程
【规则6-1】过程名称的含义与其实现的功能保持一致，每部分单词首字母大写，命名采用分层思想。 
示例：二层地址学习 proc LswL2Address { } 
LSW为第一层，即代表产品。 
L2为第二层，代表产品的某项功能或特性。 
Address为第三层，代表产品的某项功能或特性的子功能。 
这样可以减少proc同名的几率。 
【规则6-2】过程名称和形参变量名用大小写混排的方式，并反应出实际意义。 
示例：二层地址学习 proc LswL2Address {mode prestr} 
【规则6-3】过程注释风格。过程的头部应进行注释，列出：过程名称、过程功能、输入参数、输出参数、返回值、调用关系、使用说明。 
示例：下面示例比较标准，当然并不局限于此格式，但上述信息建议要包含在内。 
############################################################# 
# 过程名称： LinkSMB 
# 过程功能： 通过网口与SMB进行连接 
# 入口参数： 
# smbIp SMB的IP地址 
# linkPara 连接参数，取RESERVE_ALL或RESERVE_NONE， 
# 缺省为RESERVE_NONE 
# 出口参数： 返回OK 
# 其他说明： 无 
# 使用样例： LinkSMB 10.110.94.70 
############################################################# 
############################################################# 
# Function: // 过程名称 
# Description: // 过程功能、性能等的描述 
# Calls: // 被本过程调用的过程清单 
# Called By: // 调用本过程的过程清单 
# Input: // 输入参数说明，包括每个参数的作用、取值说明 
# // 以及参数间关系 
# Output: // 对输出参数的说明 
# Return: // 过程返回值的说明 
# Others: // 其它说明 
# Example: // 举例说明 
############################################################# 
【规则6-4】过程编程风格统一采用缩进格式 
如： 
proc Example { } { 
if{} { 
# Do something; 
} else { 
# Do something; 
} 
} 
【规则6-5】过程必须以 return 语句显式返回。 
【规则6-6】当过程返回多个参数值或者返回不定数目参数时，采用list格式返回。 
【规则6-7】过程中必须首先声明要使用的全局变量和名称空间变量。 
【建议6-1】过程设计应完成单一完整的功能，避免设计多用途面面俱到的过程。 
【建议6-2】设计高扇入、合理扇出（小于7）的过程。对于功能不明确且规模较小的过程，特别是仅有一个上级过程调用它时，应考虑把它合并到上级过程中，而不必单独存在。 
说明：扇出是指一个过程直接调用（控制）其它过程的数目，而扇入是指有多少上级过程调用它。扇出过大，表明过程过分复杂，需要控制和协调过多的下级过程；而扇出过小，如总是1，表明过程的调用层次可能过多，这样不利程序阅读和过程结构的分析，并且程序运行时会对系统资源如堆栈空间等造成压力。 
【建议6-3】减少过程本身或过程间的递归调用。 
说明：递归调用特别是过程间的递归调用（如A->B->C->A），影响程序的可理解性；递 归调用一般都占用较多的系统资源（如栈空间）；递归调用对程序的测试有一定影响。故 除非为某些算法或功能的实现方便，应减少没必要的递归调用。 
【建议6-4】一般情况下，过程的规模应控制在200行以内。 
7名称空间和包
【规则7-1】名称空间里，一个variable命令只定义一个变量。 
【规则7-2】使用绝对名称（即以::开头）引用其它名称空间中的变量和过程。 
【规则7-3】包必须提供版本号，格式为“X.Y”，其中X表示主版本号，Y表示子版本号。 
【建议7-1】对于变量和过程庞杂、包含模块较多的工程，应采用名称空间组织和构建脚本，以增强脚本的可读性和可维护性，防止标识符命名冲突。 
示例：下面是从某ftp过程库中截取的一段脚本。当脚本规模急剧膨胀以后，名称空间是组织脚本，解决标识符命名冲突，提高脚本可读性和可维护性的一种有效手段。 
namespace eval FTP { 
namespace export DisplayMsg Open Close Cd Pwd\ 
Type List NList FileSize ModTime Delete\ 
Rename Put Append Get Reget Newer Quote 
set VERBOSE 1 
set DEBUG 1 
proc DisplayMsg {msg {state ""}} { 
........ 
} 
proc Timeout {} { 
........ 
} 
proc WaitOrTimeout {} { 
........ 
} 
proc WaitComplete {value} { 
........ 
} 
proc PutsCtrlSock {{command ""}} { 
........ 
} 
........ 
........ 
} 
【建议7-2】名称空间中应当首先使用export命令定义导出过程列表，列表应包括该名称空间推荐使用的过程。 
【建议7-3】包必须采用有效措施防止标识符命名冲突，如采用名称空间或模块前缀，推荐使用名称空间实现包。 
8文件操作
【规则8-1】文件命名应清楚准确，尽量使用完整的单词或基本可以理解的缩写，避免使用单个字符做文件名。 
【规则8-2】在同一个工程或模块中，文件命名风格必须保持一致。 
【规则8-3】公共脚本文件应为基于模块编程的文件，命名采用业务和模块功能相结合的规则，业务和功能模块之间采用下划线分开。文件的存取按照业务、功能模块、测试项目、测试子项目的顺序逐层展开。 
例如： 
LswTestScriptLib（文件夹） 
|______L2（文件夹） 
| |______地址管理（文件夹） 
| | |______MAC地址属性的修改.tcl 
| | |______删除动态MAC地址.tcl 
| | |______添加动态MAC地址.tcl 
| | |______………… 
【规则8-4】在文件系统操作中，尽量使用与平台无关的文件名操作命令（如file join、file split等），以利于脚本的移植。 
示例：
set FilePath [file join "Program Files" Tcl bin wish83.exe] 
【规则8-5】过程脚本文件头的注释。说明性文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。 
示例：下面这段头文件的头注释比较标准，当然，并不局限于此格式，但上述信息建议要包含在内。 
####################################################################### 
# Copyright (C), 1998-2002, Huawei Tech. Co., Ltd. 
# File name: ×××.tcl // 文件名 
# Author: *** Version: *** Date: *** // 作者、版本及完成日期 
# Description: // 用于详细说明此程序文件完成的主要功能，与其他模块 
# // 或函数的接口，输出值、取值范围、含义及参数间的控 
# // 制、顺序、独立或依赖等关系 
# Others: // 其它内容的说明 
# Function List: // 主要函数列表，每条记录应包括函数名及功能简要说明 
# 1. .... // 对外提供的接口函数 
# 2...... // 内部函数 
# History: // 修改历史记录列表，每条修改记录应包括修改日期、 
# // 修改作者及修改内容简述 
# Author Date Modification 
# 1. ... 
# 2. ... 
######################################################################### 
【规则8-6】业务脚本文件头的注释。说明性文件头部应进行注释，注释必须列出：版权说明、脚本名称、脚本编号、对应的测试用例编号、功能描述、版本号、生成日期、作者、修改日志等。 
示例： 
########################################################### 
# 版权所有: 2001-2003, 华为技术有限公司 
# 脚本名称: MAC地址属性的修改 
# 功能描述: MAC地址属性的修改 
# 脚本编号: LSW_L2_地址管理_10 
# 用例编号: LSW_L2_地址管理_10 
# 历史记录: 作者 日期 修改记录 
# 张三 06-18-2002 v2.0 
# 其 他: 
########################################################### 
【规则8-7】其它脚本文件头的注释。说明性文件头部应进行注释，注释必须列出：版权说明、脚本名称、功能描述、版本号、生成日期、作者、修改日志等。 
示例： 
########################################################### 
# 版权所有: 2001-2003, 华为技术有限公司 
# 脚本名称: DiagTestStart 
# 功能描述: 启动DIAG模块自动测试 
# 历史记录: 作者 日期 修改记录 
# 张三 06-16-2002 v2.0 
# 其 他: 
########################################################### 
【规则8-8】为了避免文件被重复编译，应在文件头加上条件编译语句。注意：如果不是公共脚本文件，可以不采用这种格式。 
示例： 
if {[info exists __NAVINT20020801_TCL__] = = 0} { 
set __NAVINT20020801_TCL__ 1 
... 
######################### 
# 公共脚本 proc 实现 
######################### 
#End of __NAVINT20020801_TCL__ 
} 
【建议8-1】利用source命令引用外部文件时，尽量使用相对路径。 
9出错和调试
【规则9-1】如非必要，用户不得修改Tcl解释器内部定义的全局变量errorInfo和errorCode。 
【规则9-2】使用错误捕获命令catch 截取脚本执行过程中的错误时，对于无法处理的错误，应该用error命令原样打印出来。 
示例：使用catch命令和error命令来处理错误
if [catch "msgtest $gSendID $gRecvID $pMsg" result] { 
if {$result == "no acknowledge"} { 
#没有应答时的处理 
} elseif {$result == "acknowledge error"} { 
#应答错误时的处理 
} else { 
error $result ; #未知错误，原样打印 
} 
} 
【建议9-1】脚本调试过程中可能需要添加打印语句，此时建议用自己的debug命令封装puts命令打印出错信息。脚本调试通过后，通过proc debug {args} {} 命令去除调试打印信息。 
示例：一种简单的自定义debug命令。
proc debug {args} { 
puts $args 
} 
10移植
【建议10-1】对于移植的Tcl 脚本，保持原有风格不做改动。 
【建议10-2】对于由测试工具自动生成的脚本，保持原有风格不做改动。 
【建议10-3】移植脚本时，应采取有效措施防止标识符命名冲突，如名称空间或模块前缀等，推荐使用名称空间。 
【建议10-4】尽量采用包结合名字空间的方式移植Tcl 脚本。 
【建议10-5】在一个工程或模块中，依赖于特殊软、硬件特性的脚本应当尽量与其它脚本隔离，如单独放在某几个文件和过程中。 
11优化
关注脚本的效率需求瓶颈，优先考虑实时性要求高的脚本和频繁调用的脚本的效率，在此基础上，局部效率要服从全局效率。 
【规则11-2】循环体内工作量最小化。 
【规则11-3】程序中分配的内存，在程序退出之前要释放。 
示例：如果在程序中使用了struct_new 指令定义了某个变量，则要注意在适当的地方（例如程序尾部）使用unset 将该变量释放掉，否则会有内存丢失的可能。 
【建议11-1】对于实时性要求较高的被测系统，可以将耗时较多的处理通过扩展函数利用C/C++实现，以满足编程系统的实时要求。 
【建议11-2】尽量减少循环嵌套层次。 
【建议11-3】多重循环中，应将最忙的循环放在最内层。 
【建议11-4】尽量避免过程本身或过程间的递归调用。 
12业务脚本写作要求
【规则12-1】正则表达式务必判断是否匹配成功。
【规则12-2】尽量不用单一关键字去判断是否有业务是否正确，要结合回显的上下文。
